create table "public"."answers" (
    "from" uuid not null,
    "directed_to" uuid not null,
    "question" bigint not null,
    "value" real not null
);


alter table "public"."answers" enable row level security;

create table "public"."games" (
    "created_at" timestamp with time zone not null default now(),
    "host" uuid not null,
    "id" uuid not null default gen_random_uuid(),
    "question" bigint,
    "target_player" uuid
);


alter table "public"."games" enable row level security;

create table "public"."players_game" (
    "player_id" uuid not null,
    "game_id" uuid not null,
    "is_ready" boolean not null default false
);


alter table "public"."players_game" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "username" text not null
);


alter table "public"."profiles" enable row level security;

create table "public"."questions" (
    "id" bigint generated by default as identity not null,
    "author" uuid,
    "prompt" text not null,
    "left_text" text,
    "right_text" text
);


alter table "public"."questions" enable row level security;

CREATE UNIQUE INDEX answers_pkey ON public.answers USING btree ("from", directed_to, question);

CREATE UNIQUE INDEX games_host_key ON public.games USING btree (host);

CREATE UNIQUE INDEX games_pkey ON public.games USING btree (id);

CREATE UNIQUE INDEX players_game_pkey ON public.players_game USING btree (player_id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX questions_pkey ON public.questions USING btree (id);

alter table "public"."answers" add constraint "answers_pkey" PRIMARY KEY using index "answers_pkey";

alter table "public"."games" add constraint "games_pkey" PRIMARY KEY using index "games_pkey";

alter table "public"."players_game" add constraint "players_game_pkey" PRIMARY KEY using index "players_game_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."questions" add constraint "questions_pkey" PRIMARY KEY using index "questions_pkey";

alter table "public"."answers" add constraint "answers_directed_to_fkey" FOREIGN KEY (directed_to) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."answers" validate constraint "answers_directed_to_fkey";

alter table "public"."answers" add constraint "answers_from_fkey" FOREIGN KEY ("from") REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."answers" validate constraint "answers_from_fkey";

alter table "public"."answers" add constraint "answers_question_fkey" FOREIGN KEY (question) REFERENCES questions(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."answers" validate constraint "answers_question_fkey";

alter table "public"."games" add constraint "games_host_fkey" FOREIGN KEY (host) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."games" validate constraint "games_host_fkey";

alter table "public"."games" add constraint "games_host_key" UNIQUE using index "games_host_key";

alter table "public"."games" add constraint "games_question_fkey" FOREIGN KEY (question) REFERENCES questions(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."games" validate constraint "games_question_fkey";

alter table "public"."games" add constraint "games_target_player_fkey" FOREIGN KEY (target_player) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."games" validate constraint "games_target_player_fkey";

alter table "public"."players_game" add constraint "players_game_game_id_fkey" FOREIGN KEY (game_id) REFERENCES games(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."players_game" validate constraint "players_game_game_id_fkey";

alter table "public"."players_game" add constraint "players_game_player_id_fkey" FOREIGN KEY (player_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."players_game" validate constraint "players_game_player_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."questions" add constraint "questions_author_fkey" FOREIGN KEY (author) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."questions" validate constraint "questions_author_fkey";

create or replace view "public"."game_answers" as  SELECT games.id AS game_id,
    games.target_player AS target_player_id,
    players_game.player_id,
    players.username AS player_username,
    answers.value AS answer_value
   FROM (((((games
     JOIN players_game ON ((games.id = players_game.game_id)))
     JOIN profiles players ON ((players.id = players_game.player_id)))
     JOIN profiles host ON ((host.id = games.host)))
     LEFT JOIN questions ON ((questions.id = games.question)))
     LEFT JOIN answers ON (((answers.question = games.question) AND (answers.directed_to = games.target_player) AND (players.id = answers."from"))));


create or replace view "public"."game_data" as  SELECT games.id AS game_id,
    games.host AS host_id,
    host.username AS host_username,
    games.question AS question_id,
    questions.prompt AS question_prompt,
    questions.left_text AS question_left,
    questions.right_text AS question_right,
    games.target_player AS target_player_id,
    target.username AS target_player_username
   FROM (((games
     JOIN profiles host ON ((host.id = games.host)))
     LEFT JOIN profiles target ON ((target.id = games.target_player)))
     LEFT JOIN questions ON ((questions.id = games.question)));


create or replace view "public"."random_players" as  SELECT players.id,
    players.username,
    games.id AS game_id
   FROM ((games
     JOIN players_game ON ((players_game.game_id = games.id)))
     JOIN profiles players ON ((players.id = players_game.player_id)))
  ORDER BY (random());


create or replace view "public"."random_questions" as  SELECT questions.id,
    questions.author,
    questions.prompt,
    questions.left_text,
    questions.right_text
   FROM questions
  ORDER BY (random());


create policy "Enable delete for users based on user_id"
on "public"."answers"
as permissive
for delete
to public
using ((auth.uid() = "from"));


create policy "Enable insert for authenticated users based on auth"
on "public"."answers"
as permissive
for insert
to authenticated
with check ((auth.uid() = "from"));


create policy "Enable read access for all users"
on "public"."answers"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on auth"
on "public"."answers"
as permissive
for update
to public
using ((auth.uid() = "from"))
with check ((auth.uid() = "from"));


create policy "Enable delete access for host"
on "public"."games"
as permissive
for delete
to public
using ((auth.uid() = host));


create policy "Enable insert for users based on user_id"
on "public"."games"
as permissive
for insert
to public
with check (true);


create policy "Enable read access for all users"
on "public"."games"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on auth"
on "public"."games"
as permissive
for update
to public
using ((auth.uid() = host))
with check ((auth.uid() = host));


create policy "Enable delete for users based on user_id"
on "public"."players_game"
as permissive
for delete
to public
using ((auth.uid() = player_id));


create policy "Enable insert for authenticated users only"
on "public"."players_game"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."players_game"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on email"
on "public"."players_game"
as permissive
for update
to public
using ((auth.uid() = player_id))
with check ((auth.uid() = player_id));


create policy "Enable insert access for all users"
on "public"."profiles"
as permissive
for insert
to public
with check (true);


create policy "Enable read access for all users"
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on user_id"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id))
with check (true);


create policy "Enable read access for all users"
on "public"."questions"
as permissive
for select
to public
using (true);
